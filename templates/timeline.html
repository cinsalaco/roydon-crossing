<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Roydon Level Crossing - Timeline</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: white;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .back-button {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #f5f5f5;
            color: #333;
            text-decoration: none;
            transition: background 0.3s;
        }

        .back-button:hover {
            background: #e0e0e0;
        }

        .header h1 {
            font-size: 20px;
            font-weight: 600;
            color: #333;
            flex: 1;
            text-align: center;
        }

        .timeline-container {
            flex: 1;
            overflow-y: auto;
            padding: 30px 20px;
        }

        .timeline {
            max-width: 800px;
            margin: 0 auto;
            position: relative;
        }

        .timeline-item {
            position: relative;
            margin-bottom: 0;
            padding-left: 140px;
            min-height: 80px;
            display: flex;
            align-items: center;
        }

        .timeline-item::before {
            content: '';
            position: absolute;
            left: 71px;
            top: 0;
            bottom: 0;
            width: 6px;
            background: #4CAF50;
        }

        .timeline-item.closed::before {
            background: #f44336;
        }

        .timeline-item:last-child::before {
            display: none;
        }

        .timeline-time {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 50px;
            text-align: right;
            font-weight: 700;
            font-size: 20px;
            color: #333;
        }

        .timeline-marker {
            position: absolute;
            left: 56px;
            top: 50%;
            transform: translateY(-50%);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: white;
            border: 5px solid #4CAF50;
            z-index: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
            font-weight: 700;
            color: #4CAF50;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .timeline-marker.closed {
            border-color: #f44336;
            color: #f44336;
        }

        .timeline-content {
            flex: 1;
        }

        .status-label {
            font-size: 24px;
            font-weight: 700;
            color: #333;
            margin-bottom: 5px;
        }

        .status-sublabel {
            font-size: 16px;
            color: #666;
            margin-bottom: 8px;
        }

        .status-sublabel .countdown {
            font-weight: 600;
            color: #f44336;
        }

        .train-list {
            margin-top: 8px;
        }

        .train-item {
            font-size: 15px;
            color: #666;
            margin-bottom: 3px;
        }

        .train-item.delayed {
            color: #f44336;
        }

        .brief-opening {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #4CAF50;
            font-weight: 600;
            margin: 8px 0;
            padding: 6px 10px;
            background: rgba(76, 175, 80, 0.1);
            border-radius: 4px;
            border-left: 3px solid #4CAF50;
        }

        .brief-opening .material-icons {
            font-size: 16px;
        }

        .no-trains {
            text-align: center;
            padding: 60px 20px;
            color: #999;
        }

        .no-trains .material-icons {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.3;
        }

        .loading {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }

        .footer {
            background: white;
            padding: 15px 20px;
            box-shadow: 0 -2px 4px rgba(0,0,0,0.1);
            text-align: center;
            font-size: 12px;
            color: #999;
        }

        @media (max-width: 600px) {
            .timeline-container {
                padding: 20px 15px;
            }

            .timeline-item {
                padding-left: 110px;
            }

            .timeline-item::before {
                left: 61px;
            }

            .timeline-marker {
                left: 46px;
                width: 32px;
                height: 32px;
            }

            .timeline-time {
                font-size: 18px;
            }

            .status-label {
                font-size: 20px;
            }

            .status-sublabel {
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <a href="/" class="back-button">
            <span class="material-icons">arrow_back</span>
        </a>
        <h1>Next 90 minutes</h1>
    </div>

    <div class="timeline-container">
        <div class="timeline" id="timeline">
            <div class="loading">
                <p>Loading train schedule...</p>
            </div>
        </div>
    </div>

    <div class="footer">
        Last updated: <span id="lastUpdated">--:--</span> | Data provided by National Rail
    </div>

    <script>
        const STATION_CODE = 'RYN';
        const REFRESH_INTERVAL = 5000; // 5 seconds for real-time updates
        const CLOSURE_GAP_MINUTES = 3;
        const CLOSURE_BEFORE_TRAIN_MINUTES = 2;
        const CLOSURE_BUFFER_SECONDS = 12;
        const CACHE_KEY = 'roydon_train_cache';
        const CACHE_VERSION = 2; // Increment to clear old cache format

        let currentTrainData = null;

        // Load cache from localStorage
        function loadCache() {
            try {
                const cached = localStorage.getItem(CACHE_KEY);
                if (cached) {
                    const wrapper = JSON.parse(cached);
                    // Check cache version
                    if (wrapper.version !== CACHE_VERSION) {
                        console.log('Cache version mismatch, clearing...');
                        localStorage.removeItem(CACHE_KEY);
                        return new Map();
                    }
                    const data = wrapper.cache || wrapper; // Support old format temporarily
                    const trainMap = new Map();
                    Object.entries(data).forEach(([id, train]) => {
                        trainMap.set(id, {
                            ...train,
                            actualTrainTime: new Date(train.actualTrainTime),
                            closureTime: new Date(train.closureTime)
                        });
                    });
                    return trainMap;
                }
            } catch (e) {
                console.error('Error loading cache:', e);
            }
            return new Map();
        }

        // Save cache to localStorage
        function saveCache(trainCache) {
            try {
                const cacheObj = {};
                trainCache.forEach((train, id) => {
                    cacheObj[id] = {
                        ...train,
                        actualTrainTime: train.actualTrainTime.getTime(),
                        closureTime: train.closureTime.getTime()
                    };
                });
                localStorage.setItem(CACHE_KEY, JSON.stringify({
                    version: CACHE_VERSION,
                    cache: cacheObj
                }));
            } catch (e) {
                console.error('Error saving cache:', e);
            }
        }

        async function fetchTrainData() {
            try {
                // NEW API endpoint - includes passing trains!
                const response = await fetch('/api/trains/realtime');

                if (!response.ok) {
                    throw new Error('Failed to fetch train data');
                }

                const data = await response.json();
                currentTrainData = data;
                displayTimeline();
                
                const now = new Date();
                document.getElementById('lastUpdated').textContent = now.toLocaleTimeString();
            } catch (error) {
                console.error('Error:', error);
                document.getElementById('timeline').innerHTML = `
                    <div class="no-trains">
                        <span class="material-icons">error_outline</span>
                        <p>Unable to load train data</p>
                    </div>
                `;
            }
        }

        function parseTrainTime(timeStr, estimatedTimeStr) {
            // Use estimated time if available (accounts for delays), otherwise use scheduled
            let useTime = timeStr;
            
            if (estimatedTimeStr && 
                estimatedTimeStr !== 'On time' && 
                estimatedTimeStr !== 'Delayed' && 
                estimatedTimeStr !== 'Cancelled' &&
                estimatedTimeStr.includes(':')) {
                useTime = estimatedTimeStr;
            }
            
            if (!useTime || useTime === 'On time' || useTime === 'Delayed' || useTime === 'Cancelled') {
                return null;
            }
            
            const now = new Date();
            const [hours, minutes] = useTime.split(':').map(Number);
            
            if (isNaN(hours) || isNaN(minutes)) return null;
            
            const trainTime = new Date(now);
            trainTime.setHours(hours, minutes, 0, 0);
            
            if (trainTime < now) {
                trainTime.setDate(trainTime.getDate() + 1);
            }
            
            return trainTime;
        }

        function displayTimeline() {
            if (!currentTrainData) return;

            const now = new Date();
            let trains = currentTrainData.trains || []; // NEW format
            
            // DEDUPLICATION: Remove duplicate trains by RID
            const uniqueTrainsMap = new Map();
            trains.forEach(train => {
                if (!uniqueTrainsMap.has(train.rid)) {
                    uniqueTrainsMap.set(train.rid, train);
                }
            });
            trains = Array.from(uniqueTrainsMap.values());
            
            // Load existing cache
            const trainCache = loadCache();
            
            // Process trains from NEW API format
            const newTrains = trains
                .map(train => {
                    // NEW format: train.time, train.eta, train.type
                    const trainTime = parseTrainTime(train.time, train.eta);
                    if (!trainTime) return null;
                    
                    const displayTime = train.eta && train.eta !== 'On time' && train.eta.includes(':') 
                        ? train.eta 
                        : train.time;
                    
                    const closureTime = new Date(trainTime.getTime() - CLOSURE_BEFORE_TRAIN_MINUTES * 60000);
                    
                    // Use RID as unique identifier
                    const trainId = train.rid;
                    
                    return {
                        trainId: trainId,
                        actualTrainTime: trainTime,
                        closureTime: closureTime,
                        displayTime: displayTime,
                        isDelayed: train.delayed || (train.eta && train.eta !== 'On time' && train.eta.includes(':')),
                        isPassing: train.type === 'passing', // NEW: track passing trains
                        type: train.type, // NEW: 'stopping' or 'passing'
                        destination: train.destination,
                        origin: train.origin,
                        toc: train.toc
                    };
                })
                .filter(train => train);
            
            // Add new trains to cache
            newTrains.forEach(train => {
                trainCache.set(train.trainId, train);
            });
            
            // Remove trains from cache that are beyond buffer time
            const bufferMilliseconds = CLOSURE_BUFFER_SECONDS * 1000;
            for (const [trainId, train] of trainCache.entries()) {
                const trainEndTime = new Date(train.actualTrainTime.getTime() + bufferMilliseconds);
                if (trainEndTime < now) {
                    trainCache.delete(trainId);
                }
            }
            
            // Save updated cache
            saveCache(trainCache);
            
            // Use cache as source of truth
            const upcomingTrains = Array.from(trainCache.values())
                .filter(train => {
                    const closureEnd = new Date(train.actualTrainTime.getTime() + bufferMilliseconds);
                    return closureEnd > now;
                })
                .sort((a, b) => a.closureTime - b.closureTime);

            if (upcomingTrains.length === 0) {
                document.getElementById('timeline').innerHTML = `
                    <div class="no-trains">
                        <span class="material-icons">train</span>
                        <p>No trains scheduled in the next 90 minutes</p>
                    </div>
                `;
                return;
            }

            // Group trains into closure groups
            const closureGroups = [];
            let currentGroup = [upcomingTrains[0]];
            
            for (let i = 1; i < upcomingTrains.length; i++) {
                const prevTrain = upcomingTrains[i - 1];
                const currentTrain = upcomingTrains[i];
                
                // Check gap between previous train passing (+ 12 sec buffer) and next closure starting
                const prevTrainEnd = new Date(prevTrain.actualTrainTime.getTime() + 12000);
                const gapMinutes = (currentTrain.closureTime - prevTrainEnd) / 1000 / 60;
                
                if (gapMinutes <= CLOSURE_GAP_MINUTES) {
                    currentGroup.push(currentTrain);
                } else {
                    closureGroups.push(currentGroup);
                    currentGroup = [currentTrain];
                }
            }
            closureGroups.push(currentGroup);

            // Build timeline with OPEN and CLOSED periods
            let timelineHTML = '';

            // Add current OPEN period if we're not in a closure
            const firstClosure = closureGroups[0];
            const minutesUntilFirst = Math.floor((firstClosure[0].closureTime - now) / 1000 / 60);
            
            if (minutesUntilFirst > 0) {
                timelineHTML += `
                    <div class="timeline-item">
                        <div class="timeline-time">Now</div>
                        <div class="timeline-marker">${minutesUntilFirst}</div>
                        <div class="timeline-content">
                            <div class="status-label">OPEN</div>
                        </div>
                    </div>
                `;
            }

            closureGroups.forEach((group, groupIndex) => {
                const firstTrain = group[0];
                const lastTrain = group[group.length - 1];
                
                // Closure ends 12 seconds after last train passes
                const closureEndTime = new Date(lastTrain.actualTrainTime.getTime() + 12000);
                const closureDuration = Math.round((closureEndTime - firstTrain.closureTime) / 1000 / 60);
                const minutesUntilClosure = Math.floor((firstTrain.closureTime - now) / 1000 / 60);
                
                // CLOSED period
                let countdownText = '';
                if (minutesUntilClosure < 60 && minutesUntilClosure >= 0) {
                    countdownText = ` <span class="countdown">(${minutesUntilClosure}m)</span>`;
                }
                
                // Build train list with brief openings between trains
                let trainListHTML = '';
                for (let i = 0; i < group.length; i++) {
                    const train = group[i];
                    const destination = train.destination || 'Unknown';
                    const origin = train.origin || 'Unknown';
                    const delayInfo = train.isDelayed ? ' (delayed)' : '';
                    const passingInfo = train.isPassing ? ' ⚡' : '';
                    
                    trainListHTML += `<div class="train-item ${train.isDelayed ? 'delayed' : ''}">${train.displayTime} ${origin} → ${destination}${delayInfo}${passingInfo}</div>`;
                    
                    // Check if there's a brief opening before the next train
                    if (i < group.length - 1) {
                        const trainEnd = new Date(train.actualTrainTime.getTime() + 12000);
                        const nextTrain = group[i + 1];
                        const gapSeconds = Math.round((nextTrain.closureTime - trainEnd) / 1000);
                        
                        // Show brief opening if gap is 30 seconds or more
                        if (gapSeconds >= 30) {
                            const openTime = trainEnd.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
                            const durationText = gapSeconds < 90 ? `~${gapSeconds}s` : `~${Math.round(gapSeconds / 60)}m`;
                            trainListHTML += `<div class="brief-opening"><span class="material-icons">lock_open</span> Brief opening at ${openTime} (${durationText})</div>`;
                        }
                    }
                }

                // Show closure start time (2 mins before first train)
                const closureStartTime = firstTrain.closureTime.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
                
                // Calculate actual closed time (excluding brief openings)
                let actualClosedSeconds = 0;
                for (let i = 0; i < group.length; i++) {
                    // Each train closure: 2 min before + 12 sec after = ~2.2 min per train
                    actualClosedSeconds += (CLOSURE_BEFORE_TRAIN_MINUTES * 60) + CLOSURE_BUFFER_SECONDS;
                    
                    // Subtract overlaps with previous train
                    if (i > 0) {
                        const prevTrainEnd = new Date(group[i-1].actualTrainTime.getTime() + 12000);
                        const thisClosureStart = group[i].closureTime;
                        const overlap = Math.max(0, (prevTrainEnd - thisClosureStart) / 1000);
                        actualClosedSeconds -= overlap;
                    }
                }
                const actualClosedMinutes = Math.round(actualClosedSeconds / 60);
                
                // Count brief openings
                let briefOpeningsCount = 0;
                for (let i = 0; i < group.length - 1; i++) {
                    const trainEnd = new Date(group[i].actualTrainTime.getTime() + 12000);
                    const nextClosureStart = group[i + 1].closureTime;
                    const gapSeconds = Math.round((nextClosureStart - trainEnd) / 1000);
                    if (gapSeconds >= 30) briefOpeningsCount++;
                }
                
                // Build label
                let closureLabel = `CLOSED for ${group.length} train${group.length > 1 ? 's' : ''} (${closureDuration}m)`;
                if (briefOpeningsCount > 0) {
                    closureLabel = `CLOSED for ${group.length} train${group.length > 1 ? 's' : ''} (${closureDuration}m, ${briefOpeningsCount} brief opening${briefOpeningsCount > 1 ? 's' : ''})`;
                }

                timelineHTML += `
                    <div class="timeline-item closed">
                        <div class="timeline-time">${closureStartTime}</div>
                        <div class="timeline-marker closed">${closureDuration}</div>
                        <div class="timeline-content">
                            <div class="status-label">${closureLabel}${countdownText}</div>
                            <div class="train-list">${trainListHTML}</div>
                        </div>
                    </div>
                `;

                // OPEN period after this closure (if there's a next group)
                if (groupIndex < closureGroups.length - 1) {
                    const nextGroup = closureGroups[groupIndex + 1];
                    const openStart = new Date(lastTrain.actualTrainTime.getTime() + 12000); // Opens 12 sec after train
                    const openEnd = nextGroup[0].closureTime; // Until next closure starts
                    const openDuration = Math.round((openEnd - openStart) / 1000 / 60);
                    
                    if (openDuration > 0) {
                        timelineHTML += `
                            <div class="timeline-item">
                                <div class="timeline-time">${openStart.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' })}</div>
                                <div class="timeline-marker">${openDuration}</div>
                                <div class="timeline-content">
                                    <div class="status-label">OPEN</div>
                                </div>
                            </div>
                        `;
                    }
                }
            });

            // Final OPEN period
            const lastGroup = closureGroups[closureGroups.length - 1];
            const lastTrain = lastGroup[lastGroup.length - 1];
            const finalOpenStart = new Date(lastTrain.actualTrainTime.getTime() + 12000);
            const endOfWindow = new Date(now.getTime() + 90 * 60000);
            const finalOpenDuration = Math.round((endOfWindow - finalOpenStart) / 1000 / 60);
            
            if (finalOpenDuration > 0) {
                timelineHTML += `
                    <div class="timeline-item">
                        <div class="timeline-time">${finalOpenStart.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' })}</div>
                        <div class="timeline-marker">${finalOpenDuration}</div>
                        <div class="timeline-content">
                            <div class="status-label">OPEN</div>
                        </div>
                    </div>
                `;
            }

            document.getElementById('timeline').innerHTML = timelineHTML;
        }

        // Start fetching data
        fetchTrainData();
        setInterval(fetchTrainData, REFRESH_INTERVAL);

        // Update timeline display every 10 seconds to keep countdown fresh
        setInterval(() => {
            if (currentTrainData) {
                displayTimeline();
            }
        }, 10000);
    </script>
</body>
</html>
