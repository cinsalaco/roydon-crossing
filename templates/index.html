<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Roydon Level Crossing</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #4CAF50;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            color: white;
        }

        body.closing {
            background: #ff9800;
        }

        body.closed {
            background: #f44336;
        }

        .header {
            background: rgba(0,0,0,0.1);
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
            color: white;
        }

        .main-display {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 30px 20px;
        }

        .crossing-status {
            text-align: center;
            max-width: 700px;
            width: 100%;
        }

        .main-message {
            font-size: 32px;
            font-weight: 600;
            margin-bottom: 20px;
            line-height: 1.3;
        }

        .time-info {
            font-size: 48px;
            font-weight: 700;
            margin-bottom: 20px;
        }

        .train-details {
            font-size: 24px;
            margin-bottom: 25px;
            opacity: 0.95;
        }

        .train-breakdown {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .breakdown-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 18px;
            opacity: 0.9;
        }

        .breakdown-item .material-icons {
            font-size: 20px;
        }

        .direction-breakdown {
            display: flex;
            justify-content: center;
            gap: 25px;
            margin-top: 12px;
            font-size: 16px;
            opacity: 0.8;
        }

        .direction-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .short-opening {
            font-size: 20px;
            margin-top: 25px;
            padding: 15px;
            background: rgba(255,255,255,0.2);
            border-radius: 8px;
        }

        .footer {
            background: rgba(0,0,0,0.1);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .timeline-link {
            display: flex;
            align-items: center;
            gap: 8px;
            color: white;
            text-decoration: none;
            font-size: 16px;
            font-weight: 500;
            background: rgba(0,0,0,0.2);
            padding: 12px 20px;
            border-radius: 8px;
            transition: background 0.3s;
        }

        .timeline-link:hover {
            background: rgba(0,0,0,0.3);
        }

        .app-info {
            font-size: 12px;
            color: rgba(255,255,255,0.8);
        }

        .app-info a {
            color: rgba(255,255,255,0.8);
            text-decoration: none;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: white;
        }

        .error {
            color: #ffeb3b;
            font-size: 14px;
            margin-top: 10px;
        }

        @media (max-width: 600px) {
            .main-message {
                font-size: 24px;
            }

            .time-info {
                font-size: 36px;
            }

            .train-details {
                font-size: 18px;
            }

            .short-opening {
                font-size: 16px;
            }

            .train-breakdown {
                gap: 20px;
            }

            .breakdown-item {
                font-size: 16px;
            }

            .direction-breakdown {
                flex-direction: column;
                gap: 8px;
                font-size: 14px;
            }

            .footer {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Roydon Level Crossing</h1>
    </div>

    <div class="main-display" id="mainDisplay">
        <div class="loading">
            <p>Loading crossing status...</p>
        </div>
    </div>

    <div class="footer">
        <a href="/timeline" class="timeline-link">
            <span class="material-icons">access_time</span>
            <span>Next 90 minutes</span>
        </a>
        <div class="app-info">
            Data provided by <a href="https://www.nationalrail.co.uk/" target="_blank">National Rail</a>
        </div>
    </div>

    <script>
        const STATION_CODE = 'RYN';
        const REFRESH_INTERVAL = 5000; // 5 seconds for real-time updates
        const CROSSING_WARNING_MINUTES = 3;
        const CLOSURE_GAP_MINUTES = 3;
        const CLOSURE_BEFORE_TRAIN_MINUTES = 2;
        const CLOSURE_BUFFER_SECONDS = 12;
        const CACHE_KEY = 'roydon_train_cache';
        const CACHE_VERSION = 2; // Increment to clear old cache format

        let upcomingTrains = [];
        let countdownInterval = null;
        let lastKnownState = null; // Track last state to prevent flashing
        let lastStateTime = null;

        // Safe localStorage wrapper
        const storage = {
            get(key) {
                try {
                    const item = localStorage.getItem(key);
                    if (!item) return null;
                    const data = JSON.parse(item);
                    // Check cache version
                    if (data.version !== CACHE_VERSION) {
                        console.log('Cache version mismatch, clearing...');
                        localStorage.removeItem(key);
                        return null;
                    }
                    return data.cache;
                } catch (e) {
                    console.error('localStorage get error:', e);
                    return null;
                }
            },
            set(key, value) {
                try {
                    localStorage.setItem(key, JSON.stringify({
                        version: CACHE_VERSION,
                        cache: value
                    }));
                    return true;
                } catch (e) {
                    console.error('localStorage set error:', e);
                    return false;
                }
            }
        };

        // Load cache from localStorage
        function loadCache() {
            const cached = storage.get(CACHE_KEY);
            if (!cached) return new Map();
            
            try {
                const trainMap = new Map();
                Object.entries(cached).forEach(([id, train]) => {
                    trainMap.set(id, {
                        ...train,
                        actualTrainTime: new Date(train.actualTrainTime),
                        closureTime: new Date(train.closureTime)
                    });
                });
                return trainMap;
            } catch (e) {
                console.error('Error parsing cache:', e);
                return new Map();
            }
        }

        // Save cache to localStorage
        function saveCache(trainCache) {
            try {
                const cacheObj = {};
                trainCache.forEach((train, id) => {
                    cacheObj[id] = {
                        trainId: train.trainId,
                        actualTrainTime: train.actualTrainTime.getTime(),
                        closureTime: train.closureTime.getTime(),
                        displayTime: train.displayTime,
                        isDelayed: train.isDelayed,
                        isArrival: train.isArrival,
                        destination: train.destination,
                        origin: train.origin
                    };
                });
                storage.set(CACHE_KEY, cacheObj);
            } catch (e) {
                console.error('Error saving cache:', e);
            }
        }

        async function fetchTrainData() {
            try {
                // NEW API endpoint (port 5002) - includes passing trains!
                const response = await fetch('/api/trains/realtime');

                if (!response.ok) {
                    throw new Error('Failed to fetch train data');
                }

                const data = await response.json();
                updateTrainData(data);
            } catch (error) {
                console.error('Error:', error);
                document.getElementById('mainDisplay').innerHTML = `
                    <div class="crossing-status">
                        <div class="main-message">Unable to load crossing data</div>
                        <div class="error">Error: ${error.message}</div>
                    </div>
                `;
            }
        }

        function parseTrainTime(timeStr, estimatedTimeStr) {
            let useTime = timeStr;
            
            if (estimatedTimeStr && 
                estimatedTimeStr !== 'On time' && 
                estimatedTimeStr !== 'Delayed' && 
                estimatedTimeStr !== 'Cancelled' &&
                estimatedTimeStr.includes(':')) {
                useTime = estimatedTimeStr;
            }
            
            if (!useTime || useTime === 'On time' || useTime === 'Delayed' || useTime === 'Cancelled') {
                return null;
            }
            
            const now = new Date();
            const [hours, minutes] = useTime.split(':').map(Number);
            
            if (isNaN(hours) || isNaN(minutes)) return null;
            
            const trainTime = new Date(now);
            trainTime.setHours(hours, minutes, 0, 0);
            
            if (trainTime < now) {
                trainTime.setDate(trainTime.getDate() + 1);
            }
            
            return trainTime;
        }

        function updateTrainData(data) {
            const now = new Date();
            let trains = data.trains || []; // NEW format uses data.trains
            
            // Deduplicate by RID
            const uniqueTrainsMap = new Map();
            trains.forEach(train => {
                if (!uniqueTrainsMap.has(train.rid)) {
                    uniqueTrainsMap.set(train.rid, train);
                }
            });
            trains = Array.from(uniqueTrainsMap.values());
            
            const trainCache = loadCache();
            
            const newTrains = trains
                .map(train => {
                    // NEW format: train.time (scheduled), train.eta (estimated), train.type (stopping/passing)
                    const trainTime = parseTrainTime(train.time, train.eta);
                    if (!trainTime) return null;
                    
                    const displayTime = train.eta && train.eta !== 'On time' && train.eta.includes(':') 
                        ? train.eta + ' (delayed)' 
                        : train.time;
                    
                    const closureTime = new Date(trainTime.getTime() - CLOSURE_BEFORE_TRAIN_MINUTES * 60000);
                    const trainId = train.rid;  // FIX: Use RID only, not RID+time
                    
                    return {
                        trainId: trainId,
                        actualTrainTime: trainTime,
                        closureTime: closureTime,
                        displayTime: displayTime,
                        isDelayed: train.delayed || false,
                        isPassing: train.type === 'passing', // NEW: track if passing train
                        type: train.type, // NEW: 'stopping' or 'passing'
                        destination: train.destination,
                        origin: train.origin
                    };
                })
                .filter(train => train && train.closureTime > now);
            
            newTrains.forEach(train => {
                trainCache.set(train.trainId, train);
            });
            
            const bufferMilliseconds = CLOSURE_BUFFER_SECONDS * 1000;
            for (const [trainId, train] of trainCache.entries()) {
                const trainEndTime = new Date(train.actualTrainTime.getTime() + bufferMilliseconds);
                if (trainEndTime < now) {
                    trainCache.delete(trainId);
                }
            }
            
            saveCache(trainCache);
            
            upcomingTrains = Array.from(trainCache.values())
                .filter(train => {
                    const closureEnd = new Date(train.actualTrainTime.getTime() + bufferMilliseconds);
                    return closureEnd > now;
                })
                .sort((a, b) => a.closureTime - b.closureTime);

            if (!countdownInterval) {
                startLiveCountdown();
            }
        }

        function startLiveCountdown() {
            countdownInterval = setInterval(updateCountdown, 1000);
            updateCountdown();
        }

        function updateCountdown() {
            const now = new Date();
            const trainCache = loadCache();
            const bufferMilliseconds = CLOSURE_BUFFER_SECONDS * 1000;
            
            let cacheChanged = false;
            for (const [trainId, train] of trainCache.entries()) {
                const trainEndTime = new Date(train.actualTrainTime.getTime() + bufferMilliseconds);
                if (trainEndTime < now) {
                    trainCache.delete(trainId);
                    cacheChanged = true;
                }
            }
            
            if (cacheChanged) {
                saveCache(trainCache);
            }
            
            upcomingTrains = Array.from(trainCache.values())
                .filter(train => {
                    const closureEnd = new Date(train.actualTrainTime.getTime() + bufferMilliseconds);
                    return closureEnd > now;
                })
                .sort((a, b) => a.closureTime - b.closureTime);
            
            if (upcomingTrains.length === 0) {
                // DEFENSIVE: If we were just in a CLOSED/CLOSING state, don't immediately show OPEN
                // This prevents flashing during cache updates
                const timeSinceLastState = lastStateTime ? (now - lastStateTime) / 1000 : Infinity;
                if ((lastKnownState === 'closed' || lastKnownState === 'closing') && timeSinceLastState < 30) {
                    // Keep showing current state briefly to prevent flash
                    // The next data refresh will correct this
                    return;
                }
                
                lastKnownState = 'open';
                lastStateTime = now;
                document.body.className = '';
                document.getElementById('mainDisplay').innerHTML = `
                    <div class="crossing-status">
                        <div class="main-message">Crossing is OPEN</div>
                        <div class="train-details">No trains in next 90 minutes</div>
                    </div>
                `;
                return;
            }

            const closureGroups = [];
            let currentGroup = [upcomingTrains[0]];
            
            for (let i = 1; i < upcomingTrains.length; i++) {
                const prevTrain = upcomingTrains[i - 1];
                const currentTrain = upcomingTrains[i];
                const prevTrainEnd = new Date(prevTrain.actualTrainTime.getTime() + 12000);
                const gapMinutes = (currentTrain.closureTime - prevTrainEnd) / 1000 / 60;
                
                if (gapMinutes <= CLOSURE_GAP_MINUTES) {
                    currentGroup.push(currentTrain);
                } else {
                    closureGroups.push(currentGroup);
                    currentGroup = [currentTrain];
                }
            }
            closureGroups.push(currentGroup);

            let nextClosure = null;
            for (const group of closureGroups) {
                const lastTrain = group[group.length - 1];
                const closureEnd = new Date(lastTrain.actualTrainTime.getTime() + 12000);
                if (closureEnd > now) {
                    nextClosure = group;
                    break;
                }
            }

            if (!nextClosure) {
                // DEFENSIVE: If we were just CLOSED/CLOSING, don't immediately show OPEN
                const timeSinceLastState = lastStateTime ? (now - lastStateTime) / 1000 : Infinity;
                if ((lastKnownState === 'closed' || lastKnownState === 'closing') && timeSinceLastState < 30) {
                    return; // Keep current display, wait for data refresh
                }
                
                lastKnownState = 'open';
                lastStateTime = now;
                document.body.className = '';
                document.getElementById('mainDisplay').innerHTML = `
                    <div class="crossing-status">
                        <div class="main-message">Crossing is OPEN</div>
                        <div class="train-details">No more trains in next 90 minutes</div>
                    </div>
                `;
                return;
            }

            const firstTrain = nextClosure[0];
            const lastTrain = nextClosure[nextClosure.length - 1];
            
            const secondsUntilClosure = Math.floor((firstTrain.closureTime - now) / 1000);
            const minutesUntilClosure = Math.floor(secondsUntilClosure / 60);
            const secondsRemaining = secondsUntilClosure % 60;
            
            const closureEndTime = new Date(lastTrain.actualTrainTime.getTime() + 12000);
            const secondsUntilClosureEnd = Math.floor((closureEndTime - now) / 1000);
            const closureEndMinutes = Math.floor(secondsUntilClosureEnd / 60);
            const closureEndSeconds = secondsUntilClosureEnd % 60;
            
            const closureDuration = Math.round((closureEndTime - firstTrain.closureTime) / 1000 / 60);
            
            // CHECK: Are we currently in a brief opening within this closure group?
            // This happens when:
            // 1. The next closure starts soon (within CLOSURE_GAP_MINUTES)
            // 2. AND we have multiple trains in the group (indicating trains have been grouped together)
            // 3. AND the gap is short enough to be a "brief" opening (not a real OPEN period)
            let inBriefOpening = false;
            let briefOpeningEndsIn = 0;
            
            // Check if any train in the current group has already passed
            // This indicates we're mid-closure and in a brief opening
            if (secondsUntilClosure > 0 && nextClosure.length >= 1) {
                for (let i = 0; i < nextClosure.length; i++) {
                    const train = nextClosure[i];
                    const trainEndTime = new Date(train.actualTrainTime.getTime() + 12000);
                    if (trainEndTime < now) {
                        // This train has passed, so we're in a brief opening
                        inBriefOpening = true;
                        briefOpeningEndsIn = secondsUntilClosure;
                        break;
                    }
                }
            }
            
            // Additional check: if closure starts very soon (< 90 seconds) AND there are multiple trains
            // This catches the case where the passed train was just removed from cache
            // but we're clearly still in a busy period
            if (!inBriefOpening && secondsUntilClosure > 0 && secondsUntilClosure <= 90 && nextClosure.length >= 2) {
                inBriefOpening = true;
                briefOpeningEndsIn = secondsUntilClosure;
            }
            
            let bodyClass, mainMessage, timeInfo, trainDetails, openingMessage;

            // Count passing vs stopping trains in this closure
            const passingCount = nextClosure.filter(t => t.isPassing).length;
            const stoppingCount = nextClosure.filter(t => !t.isPassing).length;
            
            // Count directions (to London = destination contains LIVST or origin doesn't)
            const LONDON_CODES = ['LIVST', 'LVRPLST', 'Liverpool Street'];
            const toLondonCount = nextClosure.filter(t => {
                const dest = t.destination || '';
                return LONDON_CODES.some(code => dest.includes(code) || dest === code);
            }).length;
            const fromLondonCount = nextClosure.length - toLondonCount;
            
            // Build train type description
            const trainTypeParts = [];
            if (stoppingCount > 0) trainTypeParts.push(`${stoppingCount} stopping`);
            if (passingCount > 0) trainTypeParts.push(`${passingCount} passing`);
            const trainTypeDesc = trainTypeParts.length > 0 ? trainTypeParts.join(', ') : `${nextClosure.length} trains`;
            
            // Build direction description
            const directionParts = [];
            if (toLondonCount > 0) directionParts.push(`↑ ${toLondonCount} to London`);
            if (fromLondonCount > 0) directionParts.push(`↓ ${fromLondonCount} from London`);
            const directionDesc = directionParts.join('  •  ');

            if (secondsUntilClosure <= 0 && secondsUntilClosureEnd > 0) {
                // CLOSED - train closure is active
                bodyClass = 'closed';
                lastKnownState = 'closed';
                lastStateTime = now;
                mainMessage = 'Roydon level crossing is CLOSED';
                
                if (closureEndMinutes > 0) {
                    timeInfo = `Opens in ${closureEndMinutes}:${closureEndSeconds.toString().padStart(2, '0')}`;
                } else {
                    timeInfo = `Opens in ${closureEndSeconds}s`;
                }
                
                const trainTimeDisplay = nextClosure.length === 1 
                    ? firstTrain.displayTime
                    : `${firstTrain.displayTime.split(' ')[0]} to ${lastTrain.displayTime.split(' ')[0]}`;
                    
                trainDetails = `
                    <div>(${trainTimeDisplay})</div>
                    <div class="train-breakdown">
                        ${stoppingCount > 0 ? `<span class="breakdown-item"><span class="material-icons">train</span> ${stoppingCount} stopping</span>` : ''}
                        ${passingCount > 0 ? `<span class="breakdown-item"><span class="material-icons">directions_railway</span> ${passingCount} passing</span>` : ''}
                    </div>
                    <div class="direction-breakdown">${directionDesc}</div>
                `;
                
            } else if (inBriefOpening && briefOpeningEndsIn > 0 && briefOpeningEndsIn <= CLOSURE_GAP_MINUTES * 60) {
                // BRIEF OPENING - gate may be open briefly between trains in a group
                bodyClass = 'closing'; // Amber - warning state
                lastKnownState = 'closed'; // Treat as closed for state tracking
                lastStateTime = now;
                mainMessage = 'Brief opening - next train soon';
                
                if (briefOpeningEndsIn >= 60) {
                    const mins = Math.floor(briefOpeningEndsIn / 60);
                    const secs = briefOpeningEndsIn % 60;
                    timeInfo = `Closes again in ${mins}:${secs.toString().padStart(2, '0')}`;
                } else {
                    timeInfo = `Closes again in ${briefOpeningEndsIn}s`;
                }
                
                const trainTimeDisplay = nextClosure.length === 1 
                    ? firstTrain.displayTime
                    : `${firstTrain.displayTime.split(' ')[0]} to ${lastTrain.displayTime.split(' ')[0]}`;
                    
                trainDetails = `
                    <div>(${trainTimeDisplay})</div>
                    <div class="train-breakdown">
                        ${stoppingCount > 0 ? `<span class="breakdown-item"><span class="material-icons">train</span> ${stoppingCount} stopping</span>` : ''}
                        ${passingCount > 0 ? `<span class="breakdown-item"><span class="material-icons">directions_railway</span> ${passingCount} passing</span>` : ''}
                    </div>
                    <div class="direction-breakdown">${directionDesc}</div>
                `;
                
            } else if (minutesUntilClosure < CROSSING_WARNING_MINUTES && secondsUntilClosure > 0) {
                bodyClass = 'closing';
                lastKnownState = 'closing';
                lastStateTime = now;
                const countdownStr = minutesUntilClosure > 0 
                    ? `${minutesUntilClosure}:${secondsRemaining.toString().padStart(2, '0')}`
                    : `${secondsRemaining}s`;
                mainMessage = 'Roydon level crossing will close in';
                timeInfo = `${countdownStr} for ${closureDuration} minutes`;
                
                const trainTimeDisplay = nextClosure.length === 1 
                    ? firstTrain.displayTime
                    : `${firstTrain.displayTime.split(' ')[0]} to ${lastTrain.displayTime.split(' ')[0]}`;
                    
                trainDetails = `
                    <div>(${trainTimeDisplay})</div>
                    <div class="train-breakdown">
                        ${stoppingCount > 0 ? `<span class="breakdown-item"><span class="material-icons">train</span> ${stoppingCount} stopping</span>` : ''}
                        ${passingCount > 0 ? `<span class="breakdown-item"><span class="material-icons">directions_railway</span> ${passingCount} passing</span>` : ''}
                    </div>
                    <div class="direction-breakdown">${directionDesc}</div>
                `;
                
            } else {
                bodyClass = '';
                lastKnownState = 'open';
                lastStateTime = now;
                mainMessage = 'Roydon level crossing will close in';
                timeInfo = `${minutesUntilClosure} minutes for ${closureDuration} minutes`;
                
                const trainTimeDisplay = nextClosure.length === 1 
                    ? firstTrain.displayTime
                    : `${firstTrain.displayTime.split(' ')[0]} to ${lastTrain.displayTime.split(' ')[0]}`;
                    
                trainDetails = `
                    <div>(${trainTimeDisplay})</div>
                    <div class="train-breakdown">
                        ${stoppingCount > 0 ? `<span class="breakdown-item"><span class="material-icons">train</span> ${stoppingCount} stopping</span>` : ''}
                        ${passingCount > 0 ? `<span class="breakdown-item"><span class="material-icons">directions_railway</span> ${passingCount} passing</span>` : ''}
                    </div>
                    <div class="direction-breakdown">${directionDesc}</div>
                `;
            }

            // Find ALL short openings within this closure group
            let shortOpenings = [];
            if (nextClosure.length > 1) {
                for (let i = 0; i < nextClosure.length - 1; i++) {
                    const trainEnd = new Date(nextClosure[i].actualTrainTime.getTime() + 12000);
                    const nextClosureStart = nextClosure[i + 1].closureTime;
                    const gapSeconds = Math.round((nextClosureStart - trainEnd) / 1000);
                    const gapMinutes = Math.round(gapSeconds / 60);
                    
                    // If there's a gap of 30 seconds or more, it's a potential opening
                    if (gapSeconds >= 30 && gapMinutes <= CLOSURE_GAP_MINUTES) {
                        const openTime = trainEnd.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
                        if (gapSeconds < 90) {
                            shortOpenings.push(`~${openTime} (~${gapSeconds}s)`);
                        } else {
                            shortOpenings.push(`~${openTime} (~${gapMinutes}m)`);
                        }
                    }
                }
            }
            
            // Build opening message
            if (shortOpenings.length > 0 && secondsUntilClosure < 600) { // Only show if within 10 minutes
                if (shortOpenings.length === 1) {
                    openingMessage = `Brief opening possible at ${shortOpenings[0]}`;
                } else if (shortOpenings.length <= 3) {
                    openingMessage = `Brief openings possible: ${shortOpenings.join(', ')}`;
                } else {
                    openingMessage = `${shortOpenings.length} brief openings possible between trains`;
                }
            }

            document.body.className = bodyClass;
            document.getElementById('mainDisplay').innerHTML = `
                <div class="crossing-status">
                    <div class="main-message">${mainMessage}</div>
                    <div class="time-info">${timeInfo}</div>
                    <div class="train-details">${trainDetails}</div>
                    ${openingMessage ? `<div class="short-opening">${openingMessage}</div>` : ''}
                </div>
            `;
        }

        // Start fetching data
        fetchTrainData();
        setInterval(fetchTrainData, REFRESH_INTERVAL);
    </script>
</body>
</html>
